"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const path_1 = require("path");
const CSS_EXTENSION_REGEX = /\.css['"]$/;
function generateClassNameObj(sf, cssPath) {
    // Bc cssPath includes ' or "
    cssPath = cssPath.substring(1, cssPath.length - 1);
    if (cssPath.startsWith('.')) {
        const sourcePath = sf.fileName;
        cssPath = path_1.resolve(path_1.dirname(sourcePath), cssPath);
    }
    const css = require(cssPath);
    return ts.createObjectLiteral(ts.createNodeArray(Object.keys(css).map(k => ts.createPropertyAssignment(ts.createLiteral(k), ts.createLiteral(css[k])))));
}
function importVisitor(sf, node) {
    let cssPath = node.moduleSpecifier.getText();
    let classNameObj;
    try {
        classNameObj = generateClassNameObj(sf, cssPath);
    }
    catch (e) {
        console.error(e);
        return;
    }
    // No import clause, skip
    if (!node.importClause) {
        return;
    }
    // This is the "foo" from "import * as foo from 'foo.css'"
    const { namedBindings } = node.importClause;
    // Dealing with "import * as css from 'foo.css'" only since namedImports variables get mangled
    if (namedBindings.kind !== ts.SyntaxKind.NamespaceImport) {
        return;
    }
    const importVar = namedBindings.name.getText();
    // Create 'var css = {}'
    return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(importVar, undefined, classNameObj)]));
}
function visitor(ctx, sf) {
    const visitor = (node) => {
        switch (node.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                if (CSS_EXTENSION_REGEX.test(node.moduleSpecifier.getText())) {
                    return importVisitor(sf, node) || ts.visitEachChild(node, visitor, ctx);
                }
                break;
            case ts.SyntaxKind.CallExpression:
                if (node.expression.getText() === 'require' &&
                    CSS_EXTENSION_REGEX.test(node.arguments[0].getText())) {
                    try {
                        return generateClassNameObj(sf, node.arguments[0].getText());
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
        }
        return ts.visitEachChild(node, visitor, ctx);
    };
    return visitor;
}
function default_1(opts) {
    require('css-modules-require-hook')(opts);
    return (ctx) => {
        return (sf) => ts.visitNode(sf, visitor(ctx, sf));
    };
}
exports.default = default_1;
